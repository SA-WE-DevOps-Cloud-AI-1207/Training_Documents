#########################
Day 16 : 7th Sep. 2025
#########################

	- Introduction - Containerization using Docker!
	
	- Micro-Service based application Build & Deployments :
	
		- Docker/Kubernetes!
		
		
	What is Containerization ???
	
	- Containerization ::::
	
		- It is a process of packaging the application along with its dependencies.
		
		
	- Virtual Machines ::
	
		- VMs are called as Hardware Level Virtualization
		- VMs are created using Hypervisors
		- VMS are used to run the Operating System
		- VMs will continue to run even if there is no Active Task/Application
		- VMs consume more space and time to start any application/service.	
	
	
	- Containers ::
			
		- Containers are called as OS Level Virtualization
		- Containers are created using Container Engine
		- Containers are used to run the Task/Application. Not Operating System
		- Containers will immediately go to EXIT State if there is no Active Task/Application
		- Containers consume less space and time to start any application/service.
		- Containers runs in its own dedicated/isolated address space
		
		- Core of Operating System called Kernel :
			- Namespace & Control Groups
	
		- Containers can be used to reduce the no.of VMs. But we cannot completely eliminate the VMs.
		
		
	
	
	Working with Containers ::::
	
	
	1. Infra-structure Perspectives ::
	
		Without using Containers :
		
			Jenkins_Master (VM)			==> To Create Jenkins CI/CD Pipeline Projects and schedule to the builds in the slave_nodes
																	
				Jenkins_SlaveNode1 (VM)	==> Perform Application Builds - Java Applications 
				Jenkins_SlaveNode1.1 (VM)==> Perform Application Builds - Java Applications 
				Jenkins_SlaveNode2 (VM)	==> Perform Application Builds - .Net Applications			
				Jenkins_SlaveNode3 (VM)	==> Perform Application Builds - Python Applications 
				Jenkins_SlaveNode4 (VM)	==> Perform Application Builds - Angular/NodeJS
				Jenkins_SlaveNode5 (VM)	==> Perform Application Builds - Ruby 	
			
		Using Containers :

			Jenkins_Master (VM)			==> To Create Jenkins CI/CD Pipeline Projects and schedule to the builds in the slave_nodes
																	
				Jenkins_SlaveNode1 (VM)	==> Build Server 
					Install Container Engine 
						C1 				==> Perform Application Builds - Java Applications   ==>
						C2              ==> Perform Application Builds - .Net Applications	
						C3              ==> Perform Application Builds - Python Applications 
						C4              ==> Perform Application Builds - Angular/NodeJS
						C5              ==> Perform Application Builds - Ruby 	
						
		Testing Environments :::
		
	
	2. Developers'/Deployment Perspectives ::


		- It is a process of packaging the application along with its dependencies.
		
		Dev Environment :
		
			- Create Source Code 	- Eclipe-IDE,github
			
			- Build, Create Artifacts(mywebapp.war)
			- Unit Testing 			
			- jdk17,tomcat8

			- Promote the Changes to Higher Environments 
			
		Using Containerization :
		
			- Create Source Code 	- Eclipe-IDE,github
			
			- Build, Create Artifacts(mywebapp.war)
			- Unit Testing 			

			- Package the Application along with its dependencies (mywebapp.war,jdk17,tomcat8) ===> mywebapp-Image:v1.0
			
			- Publish the Application Image to Container Registry 						
			
		
		QA :	(mywebapp.war)	==> jdk11,tomcat7
		
			Run the (mywebapp.war) ==> 
			
			Install Container Engine
			
			mywebapp-Image:v1.0(mywebapp.war,jdk17,tomcat8) will be pulled in to the QA Server using Container Engine and Create Application Containers
			
			
		UAT :

			Install Container Engine
			
			mywebapp-Image:v1.0(mywebapp.war,jdk17,tomcat8) will be pulled in to the QA Server using Container Engine and Create Application Containers
			
		
		PROD :
		 
			Install Container Engine
			
			mywebapp-Image:v1.0(mywebapp.war,jdk17,tomcat8) will be pulled in to the QA Server using Container Engine and Create Application Containers
			
			
	Terminologies/Architecture Components:
	
		- Container Engine :
			- It is used to Create and Manage Container Images and Containers.
			- Docker Container Engine 
		
			- AWS 	: ECS 
			- AZure : ACS 
			- GCP 	: GCE
			
		- Container Images :
		
			- It is a static file that defines properties of the Containers and its depedencies
			- It is Non-Executable
			- It composed of various layer of Instructions which are defined using Dockerfile.
			
		- Containers :
		
			- Containers are the executable units of Container Images. 
			- Containers are using the run the Applications defined in the Container Images. 
			- It is also called a process.
	
		- Container Registry :
		
			- It is used to save and manage the versions of Container Images.
			- Dockerhub is Container Registry to be used.
				https://hub.docker.com/	
			
			- AWS 	: ECS,ECR 
			- Azure : ACS,ACR
			- GCP 	: GCE,GCR		
			
		- Container Repositories :
		
			- Container Repositories are the sub-set of Container Registry 
			
			
			- Github 				: Version Control the Source Codes 
			
			- Artifactory Libraries : Version Control the Application Artifacts 
			
			- Container Registries  : Version Control the Application/Container Images 
			

	- Create an Account/Login to DockerHub :  https://hub.docker.com/	
			


Next ::

	- Install and work with Containers





#########################
Day 17 : 13th Sep. 2025
#########################

	- Install and work with Containers

	- Installation of Container Engine :
	
		- Install Docker Engine 
			# https://docs.docker.com/engine/install/
			
			- Launch Ubuntu Machine - v22.04  / Use the existing Jenkins SlaveNode to Install Docker Engine
			
			- sudo -i 
			- apt update -y 			
			- apt install docker.io -y


	- Working with Docker Cli Commands :
	
		docker --version

	- Working Docker Container Images
	
	- DockerHub - Container Registry ::::
	
	- Working with Docker CLI Commands :
	

		- docker --version
		
		- docker images					# To get the list of Containers Images present in Local Machine  
		
		- docker ps 					# To get the list of only the active/running Containers in Local Machine  
		
		- docker ps -a 					# To get the list all active/running/Inactive Containers in Local Machine

		- docker pull <image_name>		# It is used to download the latest version of Container Image from Container Registry.

			Eg.: 
			
				docker pull alpine
				docker pull alpine:latest 
				
				docker pull ubuntu
				
				docker pull nginx 
				
				docker pull tomcat 
			
		- docker pull <image_name>:<Tag/Version_Name>	# To download a specific version of Container Image from Container Registry.
	
			Eg.: 
			
				docker pull alpine:3.22.0	
		
				docker pull tomcat:8.0
	
	
		Create Containers using existing Container Images from Container Registry :

			
		- docker run <Container_Image_Name>		# Create a Container based on the Container Image
		
		Eg.: 
		
			docker run ubuntu 
			
			docker run alpine:latest	
	

		Three Modes of Container Executions/Run :::
		
			- Foreground/Attached Mode ::							# Default Mode of Execution.

				docker run <image_name> 
				
				Eg.: 
				
					docker run ubuntu sleep 20 		
			
			
			- Background/Detached Mode ::
			
				docker run -d <image_name> 
				
				Eg.: 
				
					docker run -d ubuntu sleep 20 		
			
			
			- Interactive Mode :
			
				docker run -it <image_name> bash 
				
				exit 								# Exit from the Container 
				
				Eg.: 		
		
				 docker run -it ubuntu bash	
				 
				 exit 								# Exit from the Container 
	
	
		- Start Container ::
		
			docker start <Container_ID> 			# Used to start the Container.


		- Login to Running Container :
		
			docker exec -it <Container_ID> bash 
			
			Eg.:
			docker exec -it 37b84fd0ecc8 bash
			
			exit 									# Log-off 
			
		- Stop Container ::
		
			docker stop <Container_ID> 				# Used to stop the Container.
		
		
		- Kill Container ::
		
			docker kill <Container_ID> 				# Used to force stop the Container.


		- Remove Container from Local Machine :
		
			docker rm <Container_ID>				# Permanently remove the Container
			
		
		- Remove Container Image from Local Machine :
		
			docker rmi <Image_ID>					# Permanently remove the Container Image
		
			docker rmi -f <Image_ID>				# Force remove the Container Image	

			
		- Get the list of Active/running Container IDs :
		
			docker ps -q
		
		
		- Stop/Kill all the Active/running Containers :
		
			docker stop $(docker ps -q)
		
			docker kill $(docker ps -q)	
			
			
		Create a Container using name tag :
		
			docker run -it --name=dev_env <image_name> bash			


	- Docker Networking ::::
	
		- Port Mapping / Port Binding 
		
		
			docker run -it tomcat:8.0 bash		 
		 
			docker run -it -p 8088:8080 tomcat:8.0 	
		 
			-p <host_port>:<container_port>
			
	
	- Docker Volumes :		# Used to maintain the persistant data.

		- Storage! 
		
		
		Dev Application :
		
			Web Application :
			
				3-Tier Application 
				
			
			Micro-Service :
			
			Layers of 3-Tier Application Architecture :::
			
				- Front-End			-- User_Interface 	- C1 
				
				- Application 		-- Business Logic 	- C2 
				
				- Back-End 			-- DataBase 		- C3
				
		
		
		Stateless Application	:::
		
			- Application that will not have any trace of execution.
		
		
		Stateful Application 	:::
		
			- Application that will have some trace of execution.
			
			
			
		docker volume list 

		docker volume create <volume_name>
		
		docker volume create sa-vol1
	
		docker volume inspect sa-vol1
		
		docker run -it --mount source=sa-vol1,destination=/sa-vol1 ubuntu bash
		
	
		
	- Create Docker Images 
	
		- Docker Commit 
		
		- Docker Build 		
	
		
	Create Container Images ::::
	
	
		docker commit ::
		
			- To Create a New Container Image based on the properties of existing Container.
			
			Syntax :

				docker commit <existing_container_id> <dockerhub_repo_name>/<New_Image_Name>:<tag_Name>
				
				
			Eg.: 
			
				docker commit 878557cff16a loksaieta/sa-java-build-env:v1.0
				
				
	Publish the Container Image to Container Registry - DockerHub :::
	
		- Use Docker CLI Commands to interact with DockerHub!
		
		- Create DockerHub Access Token :
		
			UserName :
			
				docker login -u loksaieta
			
			PAT 	 :	
			
				aasdfasdfasdfasdfasdfasdfsdf
		
		- docker push loksaieta/sa-java-build-env:v1.0
		
	

		
		Docker Build ::
		
			- To create a new Container Image based on the Dockerfile reference.
			- Dockerfile composed of Instructions to Create Docker Container Images
			- Application Developers create the Dockerfile and update in the Source Code Repository. 
		
		
			vi Dockerfile 
			
			FROM ubuntu
			RUN apt update -y 
			RUN apt install git -y 
			RUN apt install maven -y
		
		
			Syntax :
			
				docker build -t <dockerhub_repo_name>/New_Image_Name>:<tag_Name> .		# '.' refers to the Dockerfile path	
		
			Eg.: 
			
				docker build -t loksaieta/sa-java-mvnbuild-env .


		
Next :

	- Dockerfile Instructions
	
	- Prepare the Java maven web Application Image
		
	- Container orchestration 
	
		- Docker Compose 
		- Docker Swarm 
		
		- Kubernetes 
		
	- Prepare Jenkins CICD Pipeline Projects using Docker	
	
	- Kubernetes :::::
	
